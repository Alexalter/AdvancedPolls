<?php
// $Id$
// ----------------------------------------------------------------------
// Advanced Polls Module for the POST-NUKE Content Management System
// Copyright (C) 2002-2004 by Mark West
// http://www.markwest.me.uk/
// ----------------------------------------------------------------------
// LICENSE
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License (GPL)
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// To read the license please visit http://www.gnu.org/copyleft/gpl.html
// ----------------------------------------------------------------------
// Original Author of file: Mark West
// Purpose of file:  Advanced Polls Administration Frontend
// ----------------------------------------------------------------------

/**
* Advanced Polls Module Administration Frontend
* @package Advanced_Polls
* @version $Id$
* @author Mark West <mark@markwest.me.uk> 
* @link http://www.markwest.me.uk Advanced Polls Support Site
* @copyright (C) 2002-2004 by Mark West
*/

/**
* the main administration function
*
* This function is the default function, and is called whenever the
* module is initiated without defining arguments.  As such it can
* be used for a number of things, but most commonly it either just
* shows the module menu and returns or calls whatever the module
* designer feels should be the default function (often this is the
* view() function)
* @author Mark West <mark@markwest.me.uk>
* @copyright (C) 2002-2004 by Mark West
* @since 1.0
* @version 1.1
*/
function advanced_polls_admin_main() 
{
	// Security check - important to do this as early as possible to avoid
	// potential security holes or just too much wasted processing.  For the
	// main function we want to check that the user has at least edit privilege
	// for some item within this component, or else they won't be able to do
	// anything and so we refuse access altogether.  The lowest level of access
	// for administration depends on the particular module, but it is generally
	// either 'edit' or 'delete'
	if (!pnSecAuthAction(0, 'advanced_polls::item', '::', ACCESS_EDIT)) {
		return pnVarPrepHTMLDisplay(_ADVANCEDPOLLSNOAUTH);
	}

    // Create output object - this object will store all of our output so that
    // we can return it easily when required
	$pnRender =& new pnRender('advanced_polls');

	// Return the output that has been generated by this function
	return $pnRender->fetch('advancedpollsadminmain.htm');
}

/**
* add new item
*
* This is a standard function that is called whenever an administrator
* wishes to create a new module item
* @author Mark West <mark@markwest.me.uk>
* @copyright (C) 2002-2004 by Mark West
* @since 1.0
* @version 1.1
*/
function advanced_polls_admin_new() 
{

	// Security check - important to do this as early as possible to avoid
	// potential security holes or just too much wasted processing
	if (!pnSecAuthAction(0, 'advanced_polls::item', '::', ACCESS_ADD)) {
		return pnVarPrepHTMLDisplay(_ADVANCEDPOLLSNOAUTH);
	}

    // Create output object - this object will store all of our output so that
    // we can return it easily when required
	$pnRender =& new pnRender('advanced_polls');

	// Language
	$pnRender->assign('languages', languagelist());

	//authorisation types
	$pnRender->assign('authtypes', array('1' => pnVarPrepForDisplay(_ADVANCEDPOLLSFREE),
								   '2' => pnVarPrepForDisplay(_ADVANCEDPOLLSUSERID),
								   '3' => pnVarPrepForDisplay(_ADVANCEDPOLLSCOOKIE),
								   '4' => pnVarPrepForDisplay(_ADVANCEDPOLLSIPADDRESS)));
	 
	//  Tiebreak options
	$pnRender->assign('tiebreaktypes', array('0' => pnVarPrepForDisplay(_ADVANCEDPOLLSNONE),
									   '1' => pnVarPrepForDisplay(_ADVANCEDPOLLSVOTETIMECOUNTBACK),
									   '2' => pnVarPrepForDisplay(_ADVANCEDPOLLSALPHABETICAL)));
	 
	//  Multiple Selection Options
	$pnRender->assign('multipleselecttypes', array('0' => pnVarPrepForDisplay(_ADVANCEDPOLLSSINGLE),
											 '1' => pnVarPrepForDisplay(_ADVANCEDPOLLSMULTIPLE),
											 '2' => pnVarPrepForDisplay(_ADVANCEDPOLLSRANKED)));

	 //  Default option count
	$pnRender->assign('defaultoptioncount', pnModGetVar('advanced_polls', 'defaultoptioncount'));
 
	// Return the output that has been generated by this function
	return $pnRender->fetch('advancedpollsadminnew.htm');
}
 
/** 
* This is a standard function that is called with the results of the
* form supplied by advanced_polls_admin_new() to create a new item
*
* @param 'pollname' the name of the poll to be created
* @param 'polldescrption' the description of the poll to be created
* @param 'polllanguage' the number of the item to be created
* @param 'pollopendid' the day component of the poll open date
* @param 'pollopenmid' the month component of the poll open date
* @param 'pollopenyid' the year component of the poll open date
* @param 'pollopenhid' the hour component of the poll open time
* @param 'pollopenminid' the minute component of the poll open time
* @param 'pollclosedid' the day component of the poll close date
* @param 'pollclosemid' the month component of the poll close date
* @param 'pollcloseyid' the year component of the poll close date
* @param 'pollclosehid' the hour component of the poll close time
* @param 'pollcloseminid' the minute component of the poll close time
* @param 'polltiebreak' the tiebreak methodlogy to use
* @param 'pollvoteauthtype' vote authorisation type to use
* @param 'multipleselect' type of poll selection
* @param 'multipleselectcount' number of selections allowed
* @param 'pollrecurring' is poll a recurring one
* @param 'pollreucrringoffset' offset for recurring polls
* @param 'pollrecurringinterval' interval to add for recurring polls
* @param 'polloptioncount' number of options for this poll
* @author Mark West <mark@markwest.me.uk>
* @copyright (C) 2002-2004 by Mark West
* @since 1.0
* @version 1.1
*/
function advanced_polls_admin_create() 
{
	// Get parameters from whatever input we need.  All arguments to this
	// function should be obtained from pnVarCleanFromInput(), getting them
	// from other places such as the environment is not allowed, as that makes
	// assumptions that will not hold in future versions of PostNuke
	list($pollname,
	    $polldescription,
		$polllanguage,
		$pollopendid,
		$pollopenmid,
		$pollopenyid,
		$pollopenhid,
		$pollopenminid,
		$pollclosedid,
		$pollclosemid,
		$pollcloseyid,
		$pollclosehid,
		$pollcloseminid,
		$pollnoclosedate,
		$polltiebreak,
		$pollvoteauthtype,
		$pollmultipleselect,
		$pollmultipleselectcount,
		$pollrecurring,
		$pollrecurringoffset,
		$pollrecurringinterval,
		$polloptioncount) = pnVarCleanFromInput('pollname',
		'polldescription',
		'polllanguage',
		'startDay',
		'startMonth',
		'startYear',
		'startHour',
		'startMinute',
		'closeDay',
		'closeMonth',
		'closeYear',
		'closeHour',
		'closeMinute',
		'pollnoclosedate',
		'polltiebreak',
		'pollvoteauthtype',
		'pollmultipleselect',
		'pollmultipleselectcount',
		'pollrecurring',
		'pollrecurringoffset',
		'pollrecurringinterval',
		'polloptioncount');

	// Confirm authorisation code.  This checks that the form had a valid
	// authorisation code attached to it.  If it did not then the function will
	// proceed no further as it is possible that this is an attempt at sending
	// in false data to the system
	if (!pnSecConfirmAuthKey()) {
		pnSessionSetVar('errormsg', _BADAUTHKEY);
		return pnRedirect(pnModURL('advanced_polls', 'admin', 'view'));
	}
	 
	// Notable by its absence there is no security check here.  This is because
	// the security check is carried out within the API function and as such we
	// do not duplicate the work here
	 
	// The API function is called.  Note that the name of the API function and
	// the name of this function are identical, this helps a lot when
	// programming more complex modules.  The arguments to the function are
	// passed in as their own arguments array
	$pid = pnModAPIFunc('advanced_polls',
		'admin',
		'create',
		 array('pollname' => $pollname,
		 'polldescription' => $polldescription,
		'polllanguage' => $polllanguage,
		'pollopendid' => $pollopendid,
		'pollopenmid' => $pollopenmid,
		'pollopenyid' => $pollopenyid,
		'pollopenhid' => $pollopenhid,
		'pollopenminid' => $pollopenminid,
		'pollclosedid' => $pollclosedid,
		'pollclosemid' => $pollclosemid,
		'pollcloseyid' => $pollcloseyid,
		'pollclosehid' => $pollclosehid,
		'pollcloseminid' => $pollcloseminid,
		'pollnoclosedate' => $pollnoclosedate,
		'polltiebreak' => $polltiebreak,
		'pollvoteauthtype' => $pollvoteauthtype,
		'pollmultipleselect' => $pollmultipleselect,
		'pollmultipleselectcount' => $pollmultipleselectcount,
		'pollrecurring' => $pollrecurring,
		'pollrecurringoffset' => $pollrecurringoffset,
		'pollrecurringinterval' => $pollrecurringinterval,
		'polloptioncount' => $polloptioncount));

	// The return value of the function is checked here, and if the function
	// suceeded then an appropriate message is posted.  Note that if the
	// function did not succeed then the API function should have already
	// posted a failure message so no action is required
	if ($pid  != false) {
		// Success
		pnSessionSetVar('statusmsg', _ADVANCEDPOLLSCREATED);
	}
	 
	// This function generated no output, and so now it is complete we redirect
	// the user to an appropriate page for them to carry on their work
	return pnRedirect(pnModURL('advanced_polls', 'admin', 'modify', array('pollid' => $pid)));
}
 
/**
* Modify a Poll
*
* This is a standard function that is called whenever an administrator
* wishes to modify a current module item
* @param 'pollid' the id of the item to be modified
* @author Mark West <mark@markwest.me.uk>
* @copyright (C) 2002-2004 by Mark West
* @since 1.0
* @version 1.1
*/
function advanced_polls_admin_modify() 
{
	// Get parameters from whatever input we need.  All arguments to this
	// function should be obtained from pnVarCleanFromInput(), getting them
	// from other places such as the environment is not allowed, as that makes
	// assumptions that will not hold in future versions of PostNuke
	$pollid = pnVarCleanFromInput('pollid');
	 
	// The user API function is called.  This takes the item ID which we
	// obtained from the input and gets us the information on the appropriate
	// item.  If the item does not exist we post an appropriate message and
	// return
	$item = pnModAPIFunc('advanced_polls',
		'user',
		'get',
		array('pollid' => $pollid));
	 
	if ($item == false) {
		return pnVarPrepHTMLDisplay(_ADVANCEDPOLLNOSUCHITEM);
	}

	// Security check - important to do this as early as possible to avoid
	// potential security holes or just too much wasted processing.  However,
	// in this case we had to wait until we could obtain the item name to
	// complete the instance information so this is the first chance we get to
	// do the check
	if (!pnSecAuthAction(0, 'advanced_polls::item', "$item[pn_title]::$pollid", ACCESS_EDIT)) {
		return pnVarPrepHTMLDisplay(_ADVANCEDPOLLSNOAUTH);
	}

	// get vote counts
	$votecount = pnModAPIFunc('advanced_polls',
		'user',
		'pollvotecount',
		array('pollid' => $pollid));

    // Create output object - this object will store all of our output so that
    // we can return it easily when required
	$pnRender =& new pnRender('advanced_polls');
	 
	$pnRender->assign('item', $item);
	$pnRender->assign('pollid', $pollid);
	
	// Language
	$pnRender->assign('languages', languagelist());

	//authorisation types
	$pnRender->assign('authtypes', array('1' => pnVarPrepForDisplay(_ADVANCEDPOLLSFREE),
								   '2' => pnVarPrepForDisplay(_ADVANCEDPOLLSUSERID),
								   '3' => pnVarPrepForDisplay(_ADVANCEDPOLLSCOOKIE),
								   '4' => pnVarPrepForDisplay(_ADVANCEDPOLLSIPADDRESS)));
	 
	//  Tiebreak options
	$pnRender->assign('tiebreaktypes', array('0' => pnVarPrepForDisplay(_ADVANCEDPOLLSNONE),
									   '1' => pnVarPrepForDisplay(_ADVANCEDPOLLSVOTETIMECOUNTBACK),
									   '2' => pnVarPrepForDisplay(_ADVANCEDPOLLSALPHABETICAL)));
	 
	//  Multiple Selection Options
	$pnRender->assign('multipleselecttypes', array('0' => pnVarPrepForDisplay(_ADVANCEDPOLLSSINGLE),
											 '1' => pnVarPrepForDisplay(_ADVANCEDPOLLSMULTIPLE),
											 '2' => pnVarPrepForDisplay(_ADVANCEDPOLLSRANKED)));

	// Return the output that has been generated by this function
	return $pnRender->fetch('advancedpollsadminmodify.htm');
}
 
 
/**
* This is a standard function that is called with the results of the
* form supplied by advanced_polls_admin_modify() to update a current item
* @param 'pollid' the id of the item to be updated
* @param 'polldescription' the descriptiom of the item to be updated
* @param 'pollname' the name of the poll to be updated
* @param 'polllanguage' the number of the item to be updated
* @param 'pollopendid' the day component of the poll open date
* @param 'pollopenmid' the month component of the poll open date
* @param 'pollopenyid' the year component of the poll open date
* @param 'pollopenhid' the hour component of the poll open time
* @param 'pollopenminid' the minute component of the poll open time
* @param 'pollclosedid' the day component of the poll close date
* @param 'pollclosemid' the month component of the poll close date
* @param 'pollcloseyid' the year component of the poll close date
* @param 'pollclosehid' the hour component of the poll close time
* @param 'pollcloseminid' the minute component of the poll close time
* @param 'polltiebreak' the tiebreak methodlogy to use
* @param 'pollvoteauthtype' vote authorisation type to use
* @param 'multipleselect' type of poll selection
* @param 'multipleselectcount' number of selections allowed
* @param 'pollrecurring' is poll a recurring one
* @param 'pollreucrringoffset' offset for recurring polls
* @param 'pollrecurringinterval' interval to add for recurring polls
* @author Mark West <mark@markwest.me.uk>
* @copyright (C) 2002-2004 by Mark West
* @since 1.0
* @version 1.1
*/
function advanced_polls_admin_update() 
{
	// Get parameters from whatever input we need.  All arguments to this
	// function should be obtained from pnVarCleanFromInput(), getting them
	// from other places such as the environment is not allowed, as that makes
	// assumptions that will not hold in future versions of PostNuke
	list($pollid,
		$pollname,
	    $polldescription,
		$polllanguage,
		$pollopendid,
		$pollopenmid,
		$pollopenyid,
		$pollopenhid,
		$pollopenminid,
		$pollclosedid,
		$pollclosemid,
		$pollcloseyid,
		$pollclosehid,
		$pollcloseminid,
		$pollnoclosedate,
		$pollvoteauthtype,
		$polltiebreak,
		$pollmultipleselect,
		$pollmultipleselectcount,
		$pollrecurring,
		$pollrecurringoffset,
		$pollrecurringinterval,
		$polloptioncount) = pnVarCleanFromInput('pollid',
		'pollname',
		'polldescription',
		'polllanguage',
		'startDay',
		'startMonth',
		'startYear',
		'startHour',
		'startMinute',
		'closeDay',
		'closeMonth',
		'closeYear',
		'closeHour',
		'startMinute',
		'pollnoclosedate',
		'pollvoteauthtype',
		'polltiebreak',
		'pollmultipleselect',
		'pollmultipleselectcount',
		'pollrecurring',
		'pollrecurringoffset',
		'pollrecurringinterval',
		'polloptioncount');

	$polloptions = array();
	for ($count = 1; $count <=$polloptioncount; $count++) {
		$polloptions[] =  array('optiontext' => pnVarCleanFromInput('polloption'.$count),
		                        'optioncolor' => pnVarCleanFromInput('polloption'.$count.'color'));
	}

	// Confirm authorisation code.  This checks that the form had a valid
	// authorisation code attached to it.  If it did not then the function will
	// proceed no further as it is possible that this is an attempt at sending
	// in false data to the system
	if (!pnSecConfirmAuthKey()) {
		pnSessionSetVar('errormsg', _BADAUTHKEY);
		return pnRedirect(pnModURL('advanced_polls', 'admin', 'view'));
	}
	 
	// Notable by its absence there is no security check here.  This is because
	// the security check is carried out within the API function and as such we
	// do not duplicate the work here
	 
	// The API function is called.  Note that the name of the API function and
	// the name of this function are identical, this helps a lot when
	// programming more complex modules.  The arguments to the function are
	// passed in as their own arguments array.
	//
	// The return value of the function is checked here, and if the function
	// suceeded then an appropriate message is posted.  Note that if the
	// function did not succeed then the API function should have already
	// posted a failure message so no action is required
	if (pnModAPIFunc('advanced_polls',
		'admin',
		'update',
		array('pollid' => $pollid,
		'pollname' => $pollname,
		'polldescription' => $polldescription,
		'polloptioncount' => $polloptioncount,
		'polllanguage' => $polllanguage,
		'pollopendid' => $pollopendid,
		'pollopenmid' => $pollopenmid,
		'pollopenyid' => $pollopenyid,
		'pollopenhid' => $pollopenhid,
		'pollopenminid' => $pollopenminid,
		'pollclosedid' => $pollclosedid,
		'pollclosemid' => $pollclosemid,
		'pollcloseyid' => $pollcloseyid,
		'pollclosehid' => $pollclosehid,
		'pollcloseminid' => $pollcloseminid,
		'pollnoclosedate' => $pollnoclosedate,
		'pollvoteauthtype' => $pollvoteauthtype,
		'polltiebreak' => $polltiebreak,
		'pollmultipleselect' => $pollmultipleselect,
		'pollmultipleselectcount' => $pollmultipleselectcount,
		'pollrecurring' => $pollrecurring,
		'pollrecurringoffset' => $pollrecurringoffset,
		'pollrecurringinterval' => $pollrecurringinterval,
		'polloptions' => $polloptions))) {
		// Success
		pnSessionSetVar('statusmsg', _ADVANCEDPOLLSUPDATED);
	}
	 
	// This function generated no output, and so now it is complete we redirect
	// the user to an appropriate page for them to carry on their work
	return pnRedirect(pnModURL('advanced_polls', 'admin', 'view'));
}
 
/**
* delete item
* This is a standard function that is called whenever an administrator
* wishes to delete a current module item.  Note that this function is
* the equivalent of both of the modify() and update() functions above as
* it both creates a form and processes its output.  This is fine for
* simpler functions, but for more complex operations such as creation and
* modification it is generally easier to separate them into separate
* functions.  There is no requirement in the PostNuke MDG to do one or the
* other, so either or both can be used as seen appropriate by the module
* developer
* @param 'pollid' the id of the item to be deleted
* @param 'confirmation' confirmation that this item can be deleted
*/
function advanced_polls_admin_delete() 
{
	// Get parameters from whatever input we need.  All arguments to this
	// function should be obtained from pnVarCleanFromInput(), getting them
	// from other places such as the environment is not allowed, as that makes
	// assumptions that will not hold in future versions of PostNuke
	list($pollid,
		$confirmation) = pnVarCleanFromInput('pollid',
		'confirmation');
	 
	// The user API function is called.  This takes the item ID which we
	// obtained from the input and gets us the information on the appropriate
	// item.  If the item does not exist we post an appropriate message and
	// return
	$item = pnModAPIFunc('advanced_polls',
		'user',
		'get',
		array('pollid' => $pollid));
	 
	if ($item == false) {
		return pnVarPrepHTMLDisplay(_ADVANCEDPOLLNOSUCHITEM);
	}
	 
	// Security check - important to do this as early as possible to avoid
	// potential security holes or just too much wasted processing.  However,
	// in this case we had to wait until we could obtain the item name to
	// complete the instance information so this is the first chance we get to
	// do the check
	if (!pnSecAuthAction(0, 'advanced_polls::item', "$item[pn_title]::$pollid", ACCESS_DELETE)) {
		return pnVarPrepHTMLDisplay(_ADVANCEDPOLLSNOAUTH);
	}
	 
	// Check for confirmation.
	if (empty($confirmation)) {
		// No confirmation yet - display a suitable form to obtain confirmation
		// of this action from the user
		 
		// Create output object - this object will store all of our output so that
		// we can return it easily when required
		$pnRender =& new pnRender('advanced_polls');
		 
		// Assign hidden form value for pollid
		$pnRender->assign('pollid', $pollid);             
		 
		// Return the output that has been generated by this function
		return $pnRender->fetch('advancedpollsadmindelete.htm');
	}
	 
	// If we get here it means that the user has confirmed the action
	 
	// Confirm authorisation code.  This checks that the form had a valid
	// authorisation code attached to it.  If it did not then the function will
	// proceed no further as it is possible that this is an attempt at sending
	// in false data to the system
	if (!pnSecConfirmAuthKey()) {
		pnSessionSetVar('errormsg', _BADAUTHKEY);
		return pnRedirect(pnModURL('advanced_polls', 'admin', 'view'));
	}
	 
	// The API function is called.  Note that the name of the API function and
	// the name of this function are identical, this helps a lot when
	// programming more complex modules.  The arguments to the function are
	// passed in as their own arguments array.
	//
	// The return value of the function is checked here, and if the function
	// suceeded then an appropriate message is posted.  Note that if the
	// function did not succeed then the API function should have already
	// posted a failure message so no action is required
	if (pnModAPIFunc('advanced_polls',
		'admin',
		'delete',
		array('pollid' => $pollid))) {
		// Success
		pnSessionSetVar('statusmsg', _ADVANCEDPOLLSDELETED);
	}
	 
	// This function generated no output, and so now it is complete we redirect
	// the user to an appropriate page for them to carry on their work
	return pnRedirect(pnModURL('advanced_polls', 'admin', 'view'));
}
 
/**
* Main admin function to view a full list of polls
* @author Mark West <mark@markwest.me.uk>
* @copyright (C) 2002-2004 by Mark West
* @since 1.0
* @version 1.1
*/
function advanced_polls_admin_view() 
{
	// Security check - important to do this as early as possible to avoid
	// potential security holes or just too much wasted processing
	if (!pnSecAuthAction(0, 'advanced_polls::item', '::', ACCESS_EDIT)) {
		return pnVarPrepHTMLDisplay(_ADVANCEDPOLLSNOAUTH);
	}

	// Get parameters from whatever input we need.  All arguments to this
	// function should be obtained from pnVarCleanFromInput(), getting them
	// from other places such as the environment is not allowed, as that makes
	// assumptions that will not hold in future versions of PostNuke
	$startnum = pnVarCleanFromInput('startnum');
	 
    // Create output object - this object will store all of our output so that
    // we can return it easily when required
	$pnRender =& new pnRender('advanced_polls');
	 
	// The user API function is called.  This takes the number of items
	// required and the first number in the list of all items, which we
	// obtained from the input and gets us the information on the appropriate
	// items.
	$items = pnModAPIFunc('advanced_polls',
		'user',
		'getall',
		array('checkml' => false,
		      'startnum' => $startnum,
		      'numitems' => pnModGetVar('advanced_polls',
                                        'adminitemsperpage')));

	$polls = array();
	foreach ($items as $item) {

		if (pnSecAuthAction(0, 'advanced_polls::item', "$item[polltitle]::$item[pollid]", ACCESS_READ)) {
			 
			// Options for the item.  Note that each item has the appropriate
			// levels of authentication checked to ensure that it is suitable
			// for display
			$options = array();
			if (pnSecAuthAction(0, 'advanced_polls::item', "$item[polltitle]::$item[pollid]", ACCESS_EDIT)) {
				$options[] = array('url' => pnModURL('advanced_polls', 'admin', 'modify', array('pollid' => $item['pollid'])),
								   'title' => _EDIT);
				if (pnSecAuthAction(0, 'advanced_polls::item', "$item[polltitle]::$item[pollid]", ACCESS_DELETE)) {
					$options[] = array('url' => pnModURL('advanced_polls', 'admin', 'delete', array('pollid' => $item['pollid'])),
									   'title' => _DELETE);
				}
				$options[] = array('url' => pnModURL('advanced_polls', 'admin', 'resetvotes', array('pollid' => $item['pollid'])),
								   'title' => _ADVANCEDPOLLSRESETVOTES);
				$options[] = array('url' => pnModURL('advanced_polls', 'admin', 'duplicate', array('pollid' => $item['pollid'])),
								   'title' => _ADVANCEDPOLLSDUPLICATE);
				$options[] = array('url' => pnModURL('advanced_polls', 'admin', 'adminstats', array('pollid' => $item['pollid'])),
								   'title' => _ADVANCEDPOLLSADMINSTATS);
			}
			$polls[] = array('polltitle' => $item['polltitle'],
							 'pollid' => $item['pollid'],
							 'options' => $options);
			
		}
	}
	$pnRender->assign('polls', $polls);

	// Assign the values for the smarty plugin to produce a pager in case of there
	// being many items to display.
	//
	// Note that this function includes another user API function.  The
	// function returns a simple count of the total number of items in the item
	// table so that the pager function can do its job properly
	$pnRender->assign('pager', array('numitems' => pnModAPIFunc('advanced_polls', 'user', 'countitems'),
							   'itemsperpage' => pnModGetVar('advanced_polls', 'adminitemsperpage')));

	// Return the output that has been generated by this function
	return $pnRender->fetch('advancedpollsadminview.htm');
}

/**
* This is a standard function to modify the configuration parameters of the
* module
* @author Mark West <mark@markwest.me.uk>
* @copyright (C) 2002-2004 by Mark West
* @since 1.0
* @version 1.1
*/
function advanced_polls_admin_modifyconfig() 
{
	// Security check - important to do this as early as possible to avoid
	// potential security holes or just too much wasted processing
	if (!pnSecAuthAction(0, 'advanced_polls::', '::', ACCESS_ADMIN)) {
		return pnVarPrepHTMLDisplay(_ADVANCEDPOLLSNOAUTH);
	}

    // Create output object - this object will store all of our output so that
    // we can return it easily when required
	$pnRender =& new pnRender('advanced_polls');

	$pnRender->assign('dateformats', array('_DATELONG' => ml_ftime(_DATELONG,time()),
									 '_DATETIMEBRIEF' => ml_ftime(_DATETIMEBRIEF, time()),
									 '_DATETIMELONG' => ml_ftime(_DATETIMELONG, time())));
	$pnRender->assign('admindateformat', pnModGetVar('advanced_polls','admindateformat'));
	$pnRender->assign('userdateformat', pnModGetVar('advanced_polls','userdateformat'));
	$pnRender->assign('adminitemsperpage', pnModGetVar('advanced_polls','adminitemsperpage'));
	$pnRender->assign('useritemsperpage', pnModGetVar('advanced_polls','useritemsperpage'));

	$pnRender->assign('usereversedns', pnModGetVar('advanced_polls', 'usereversedns'));
	$pnRender->assign('scalingfactor', pnModGetVar('advanced_polls', 'scalingfactor'));

	$pnRender->assign('defaultcolour', pnModGetVar('advanced_polls', 'defaultcolour'));
	$pnRender->assign('defaultoptioncount', pnModGetVar('advanced_polls', 'defaultoptioncount'));
	
	// Return the output that has been generated by this function
	return $pnRender->fetch('advancedpollsadminmodifyconfig.htm');
}

/**
* This is a standard function to update the configuration parameters of the
* module given the information passed back by the modification form
* @author Mark West <mark@markwest.me.uk>
* @copyright (C) 2002-2004 by Mark West
* @since 1.0
* @version 1.1
*/
function advanced_polls_admin_updateconfig() 
{
	// Get parameters from whatever input we need.  All arguments to this
	// function should be obtained from pnVarCleanFromInput(), getting them
	// from other places such as the environment is not allowed, as that makes
	// assumptions that will not hold in future versions of PostNuke
	list($polladmindateformat,
		 $polluserdateformat,
		 $pollusereversedns,
		 $pollscalingfactor,
		 $adminitemsperpage,
		 $useritemsperpage,
		 $defaultcolour,
		 $defaultoptioncount) = pnVarCleanFromInput('polladmindateformat',
												   'polluserdateformat',
												   'pollusereversedns',
												   'pollscalingfactor',
												   'polladminitemsperpage',
												   'polluseritemsperpage',
												   'defaultcolour',
												   'defaultoptioncount');

	// Confirm authorisation code.  This checks that the form had a valid
	// authorisation code attached to it.  If it did not then the function will
	// proceed no further as it is possible that this is an attempt at sending
	// in false data to the system
	if (!pnSecConfirmAuthKey()) {
		pnSessionSetVar('errormsg', _BADAUTHKEY);
		return pnRedirect(pnModURL('advanced_polls', 'admin', 'view'));
	}

	// Update module variables.  Note that depending on the HTML structure used
	// to obtain the information from the user it is possible that the values
	// might be unset, so it is important to check them all and assign them
	// default values if required
	if (!isset($polladmindateformat)) {
		$polladmindateformat = 'r';
	}
	pnModSetVar('advanced_polls', 'admindateformat', $polladmindateformat);
	if (!isset($polluserdateformat)) {
		$polluserdateformat = 'r';
	}
	pnModSetVar('advanced_polls', 'userdateformat', $polluserdateformat);
	if (!isset($pollusereversedns)) {
		$pollusereversedns = 0;
	}
	pnModSetVar('advanced_polls', 'usereversedns', $pollusereversedns);
	 
	if (!isset($pollscalingfactor)) {
		$pollscalingfactor = 4;
	}
	pnModSetVar('advanced_polls', 'scalingfactor', $pollscalingfactor);
	if (!isset($adminitemsperpage)) {
		$adminitemsperpage = 25;
	}
	pnModSetVar('advanced_polls', 'adminitemsperpage', $adminitemsperpage);
	if (!isset($useritemsperpage)) {
		$useritemsperpage = 25;
	}
	pnModSetVar('advanced_polls', 'useritemsperpage', $useritemsperpage);
	if (!isset($defaultcolour)) {
	    $defaultcolour = '#000000';
	}
	pnModSetVar('advanced_polls', 'defaultcolour', $defaultcolour);
	if (!isset($defaultoptioncount)) {
	    $defaultoptioncount = '12';
	}
	pnModSetVar('advanced_polls', 'defaultoptioncount', $defaultoptioncount);

	// This function generated no output, and so now it is complete we redirect
	// the user to an appropriate page for them to carry on their work
	return pnRedirect(pnModURL('advanced_polls', 'admin', 'view'));
}

/**
* Reset the votes on a poll
* @author Mark West <mark@markwest.me.uk>
* @copyright (C) 2002-2004 by Mark West
* @since 1.1
* @version 1.1
*/
function advanced_polls_admin_resetvotes() 
{
	// Security check - important to do this as early as possible to avoid
	// potential security holes or just too much wasted processing
	if (!pnSecAuthAction(0, 'advanced_polls::item', '::', ACCESS_EDIT)) {
		return pnVarPrepHTMLDisplay(_ADVANCEDPOLLSNOAUTH);
	}

	// Get parameters
	list($pollid, 
		 $confirmation) = pnVarCleanFromInput('pollid',
											  'confirmation');

	// Check for confirmation
	if (empty($confirmation)) {
		// No confirmation yet - get one

		// Create output object - this object will store all of our output so that
		// we can return it easily when required
		$pnRender =& new pnRender('advanced_polls');

		$pnRender->assign('pollid', $pollid);
		// Return the output that has been generated by this function
		return $pnRender->fetch('advancedpollsadminresetvotes.htm');
	}

	// Confirm authorisation code
	if (!pnSecConfirmAuthKey()) {
		pnSessionSetVar('errormsg', _BADAUTHKEY);
		return pnRedirect(pnModURL('advanced_polls', 'admin', 'view'));
	}

	// Pass to API
	if (pnModAPIFunc('advanced_polls', 'admin', 'resetvotes', array('pollid' => $pollid))) {
		// Success
		pnSessionSetVar('statusmsg', _ADVANCEDPOLLSVOTESRESET);
	}

	return pnRedirect(pnModURL('advanced_polls', 'admin', 'view'));
}

/**
* Display voting statistics to admin
* @author Mark West <mark@markwest.me.uk>
* @copyright (C) 2002-2004 by Mark West
* @since 1.1
* @version 1.1
*/
function advanced_polls_admin_adminstats() 
{
	// Security check - important to do this as early as possible to avoid
	// potential security holes or just too much wasted processing
	if (!pnSecAuthAction(0, 'advanced_polls::', '::', ACCESS_ADMIN)) {
		return pnVarPrepHTMLDisplay(_ADVANCEDPOLLSNOAUTH);
	}

	// Get parameters
	$pollid = pnVarCleanFromInput('pollid');
	$sortorder = pnVarCleanFromInput('sortorder');
	$sortby = pnVarCleanFromInput('sortby');
	$startnum = pnVarCleanFromInput('startnum');
	
	// set default sort order
	if (!isset($sortorder)) {
		$sortorder = 0;
	}
	// set default sort by
	if (!isset($sortby)) {
		$sortby = 1;
	}

    // Create output object - this object will store all of our output so that
    // we can return it easily when required
	$pnRender =& new pnRender('advanced_polls');
	
	// get all votes for this poll from api
	$votes = pnModAPIFunc('advanced_polls', 'admin', 'getvotes', array('pollid' => $pollid,
																	   'sortorder' => $sortorder,
																	   'sortby' => $sortby,
																	   'startnum' => $startnum,
                                                                       'numitems' => pnModGetVar('advanced_polls',
                                                                                                 'adminitemsperpage')));

	// get all votes for this poll from api
	$item = pnModAPIFunc('advanced_polls', 'user', 'get', array('pollid' => $pollid));

	foreach ($item as $k=>$v) {
		if ($k != 'pn_optionarray') {
			$item[$k] = pnVarPrepForDisplay($v);
		}
	}
	$pnRender->assign('item', $item);
	$pnRender->assign('pollid', $pollid);
	$votecountarray = pnModAPIFunc('advanced_polls', 'user', 'pollvotecount', array('pollid'=>$pollid));
	$votecount = $votecountarray['pn_totalvotecount'];
	$pnRender->assign('votecount', $votecount);

	$pnRender->assign('sortbyoptions' , array(1 => pnVarPrepForDisplay(_ADVANCEDPOLLSVOTEID),
											  2 => pnVarPrepForDisplay(_ADVANCEDPOLLSVOTEIP),
											  3 => pnVarPrepForDisplay(_ADVANCEDPOLLSVOTETIME),
											  4 => pnVarPrepForDisplay(_ADVANCEDPOLLSVOTEUID),
											  5 => pnVarPrepForDisplay(_ADVANCEDPOLLSVOTERANK),
											  6 => pnVarPrepForDisplay(_ADVANCEDPOLLSVOTEOPTIONID)));
	$pnRender->assign('sortby', $sortby);
	
	$pnRender->assign('sortorderoptions', array(0 => pnVarPrepForDisplay(_ADVANCEDPOLLSSORTASCENDING),
										        1 => pnVarPrepForDisplay(_ADVANCEDPOLLSSORTDESCENDING)));
	$pnRender->assign('sortorder', $sortorder);

	$polloptionarray = array();
	$polloptionarray = $item['pn_optionarray'];

	$voteitems = array();
	if ($votes == true ) {
		foreach ($votes as $vote) {
			if (pnModGetVar('advanced_polls', 'usereversedns')) {
				$host = gethostbyaddr($vote['voteip']) . ' - ' . $vote['voteip'];
			} else {
				$host = $vote['voteip'];
			}
			$voteoffset = $vote['voteoptionid']-1;
			$voteitems[] = array('voteid' => $vote['voteid'],
								 'host' => $host,
								 'time' => $vote['votetime'],
								 'user' => pnUserGetVar('uname',$vote['voteuid']),
								 'rank' => $vote['voterank'],		
								 'optiontext' => $polloptionarray[$voteoffset]['optiontext']);
							
		}
	}		
	$pnRender->assign('votes', $voteitems);

	// Assign the values for the smarty plugin to produce a pager in case of there
	// being many items to display.
	//
	// Note that this function includes another user API function.  The
	// function returns a simple count of the total number of items in the item
	// table so that the pager function can do its job properly
	$pnRender->assign('pager', array('numitems' => $votecount,
							         'itemsperpage' => pnModGetVar('advanced_polls', 'adminitemsperpage')));

	return $pnRender->fetch('advancedpollsadminadminstats.htm');
}

/**
* Duplicate poll
* @author Mark West <mark@markwest.me.uk>
* @copyright (C) 2002-2004 by Mark West
* @since 1.1
* @version 1.1
*/
function advanced_polls_admin_duplicate() 
{
	// Get parameters from whatever input we need.  All arguments to this
	// function should be obtained from pnVarCleanFromInput(), getting them
	// from other places such as the environment is not allowed, as that makes
	// assumptions that will not hold in future versions of PostNuke
	list($pollid,
		 $confirmation) = pnVarCleanFromInput('pollid',
											  'confirmation');
	 
	// The user API function is called.  This takes the item ID which we
	// obtained from the input and gets us the information on the appropriate
	// item.  If the item does not exist we post an appropriate message and
	// return
	$item = pnModAPIFunc('advanced_polls',
						 'user',
						 'get',
						 array('pollid' => $pollid));
	 
	if ($item == false) {
		return pnVarPrepHTMLDisplay(_ADVANCEDPOLLNOSUCHITEM);
	}
	 
	// Security check - important to do this as early as possible to avoid
	// potential security holes or just too much wasted processing.  However,
		// in this case we had to wait until we could obtain the item name to
	// complete the instance information so this is the first chance we get to
	// do the check
	if (!pnSecAuthAction(0, 'advanced_polls::item', "$item[pn_title]::$pollid", ACCESS_EDIT)) {
		return pnVarPrepHTMLDisplay(_ADVANCEDPOLLSNOAUTH);
	}
	 
	// Check for confirmation.
	if (empty($confirmation)) {
		// No confirmation yet - display a suitable form to obtain confirmation
		// of this action from the user
		 
		// Create output object - this object will store all of our output so that
		// we can return it easily when required
		$pnRender =& new pnRender('advanced_polls');
		 
		// Assign a hidden form value for the poll id
		$pnRender->assign('pollid', $pollid);
		 
		// Return the output that has been generated by this function
		return $pnRender->fetch('advancedpollsadminduplicate.htm');
	}
	 
	// If we get here it means that the user has confirmed the action
	 
	// Confirm authorisation code.  This checks that the form had a valid
	// authorisation code attached to it.  If it did not then the function will
	// proceed no further as it is possible that this is an attempt at sending
	// in false data to the system
	if (!pnSecConfirmAuthKey()) {
		pnSessionSetVar('errormsg', _BADAUTHKEY);
		return pnRedirect(pnModURL('advanced_polls', 'admin', 'view'));
	}
	 
	// The API function is called.  Note that the name of the API function and
	// the name of this function are identical, this helps a lot when
	// programming more complex modules.  The arguments to the function are
	// passed in as their own arguments array.
	//
	// The return value of the function is checked here, and if the function
	// suceeded then an appropriate message is posted.  Note that if the
	// function did not succeed then the API function should have already
	// posted a failure message so no action is required
	if (pnModAPIFunc('advanced_polls',
		'admin',
		'duplicate',
		array('pollid' => $pollid))) {
		// Success
		pnSessionSetVar('statusmsg', _ADVANCEDPOLLSDUPLICATED);
	}
	 
	// This function generated no output, and so now it is complete we redirect
	// the user to an appropriate page for them to carry on their work
	return pnRedirect(pnModURL('advanced_polls', 'admin', 'view'));
}

?>